For the Onion Service:
	- sign the Onion Service descriptor
		ECDSA {
		   privkey := private part of the key in its address
		}

	- verify one-time secret + rdv address ??
	
	- connect to the rdv point
		trame?
	

For the client:
	- verify a descriptor signature (with the address of the service)
	- send a one-time secret to the rendez-vous point
	- send the same one-time secret and the rendez-vous address to the service through one of the introduction points



For the rendez-vous point:
	- match the secrets from both sides
		

Sources : 
https://github.com/ecies/py
https://pypi.org/project/secp256k1/
https://www.quickprogrammingtips.com/python/aes-256-encryption-and-decryption-in-python.html
https://stackoverflow.com/questions/34653875/python-how-to-send-data-over-tcp


Pour signer :

	from secp256k1 import PrivateKey
	key = PrivateKey()

	base64.b64encode(key.ecdsa_serialize_compact(key.ecdsa_sign(b'bibiuiuhiuh')))


Pour chiffrer avec ECIES :

	from ecies import encrypt
	encrypt('0x' + key.pubkey.serialize().hex(), b'bygbybiu')


Pour déchiffrer avec ECIES et récupérer la clef AES :

	decrypt('0x'+key.serialize(), base64.b64decode(c))


Pour exporter la clef publique :

	base64.b64encode(key.pubkey.serialize())


Pendant l'établissement des clefs:
 - à destination de 1: 
		Base64(ECIES(Pickle({I1, K1})))
 - à destination de 2:
		Base64(AES(Pickle({I2, Base64(ECIES(Pickle({I2, K2})))}), K1))
 - à destination de 3:
		Base64(AES(Pickle({I2, Base64(AES(Pickle({I3, Base64(ECIES(Pickle({I3, K3})))})), K2)}), K1))
 - à destination de Noeud au bout:
		Base64(AES(Pickle({I2, Base64(AES(Pickle({I3, Base64(AES(Pickle({N2, Base64(ECIES(Pickle({N2, K})))})), K3)})), K2)}), K1))


